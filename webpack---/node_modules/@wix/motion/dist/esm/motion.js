import _defineProperty from "@babel/runtime/helpers/defineProperty";
import {
    scrollAnimations
} from './library/scroll';
import {
    entranceAnimations
} from './library/entrance';
import {
    ongoingAnimations
} from './library/ongoing';
import {
    mouseAnimations
} from './library/mouse';
import {
    backgroundScrollAnimations
} from './library/backgroundScroll';
import {
    getCssUnits,
    getEasing
} from './utils';
import fastdom from 'fastdom';

function getDirection(effect) {
    const alternate = effect.alternate ? 'alternate' : '';
    return effect.reversed ? `${alternate ? `${alternate}-` : ''}reverse` : alternate || 'normal';
}

/**
 * Returns the string representation of the given UnitLengthPercentage object.
 */
function getLength(length) {
    return `${length.value}${getCssUnits(length.type)}`;
}

/**
 * Returns the animation-range value for the given RangeOffset object.
 * @param {RangeOffset} range
 * @param {string|undefined} add
 * @param {boolean} [isEnd]
 */
function getRange(range, add, isEnd) {
    // according to the CSS spec if the end range is a <length> then it is calculated from the start of the named range
    // our model assumes that <length> in end range is calculated from the end of the named range
    return `${range.name} ${isEnd && range.offset.type !== 'percentage' ? `calc(100% + ${getLength(range.offset)}${add ? ` + ${add}` : ''})` : add ? `calc(${getLength(range.offset)} + ${add})` : getLength(range.offset)}`;
}

/**
 * Returns the element with the given id or null if not found.
 */
function getElement(id) {
    return id ? document.getElementById(id) : null;
}

function measure(target) {
    return fn => fastdom.measure(() => fn(target));
}

function mutate(target) {
    return fn => fastdom.mutate(() => fn(target));
}

/**
 * Returns a list of AnimationData objects for the given animation options.
 * Animation presets from the library transform the options into a list of AnimationData objects.
 * @param {AnimationOptions} animation
 * @param {HTMLElement|null} target
 * @return {AnimationData[]}
 */
function getNamedEffect(animation, target) {
    if (animation.namedEffect) {
        const name = animation.namedEffect.type;
        let preset;

        // check each preset library for the named effect
        if (name in scrollAnimations) {
            preset = scrollAnimations[name];
        } else if (name in entranceAnimations) {
            preset = entranceAnimations[name];
        } else if (name in ongoingAnimations) {
            preset = ongoingAnimations[name];
        } else if (name in mouseAnimations) {
            preset = mouseAnimations[name];
        } else if (name in backgroundScrollAnimations) {
            preset = backgroundScrollAnimations[name];
        }
        if (preset) {
            // if found a matching preset then make the transformation
            return preset(animation, {
                measure: measure(target),
                mutate: mutate(target)
            });
        }
    }
    return [];
}

/**
 * @class AnimationGroup
 *
 * A wrapper object for simulating a GroupEffect and managing multiple animations.
 * See: https://www.w3.org/TR/web-animations-2/#grouping-and-synchronization
 */
class AnimationGroup {
    constructor(animations, options) {
        _defineProperty(this, "animations", void 0);
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "ready", void 0);
        this.animations = animations;
        this.options = options;
        this.ready = (options == null ? void 0 : options.measured) || Promise.resolve();
    }
    play(callback) {
        this.ready.then(() => {
            for (const animation of this.animations) {
                animation.play();
            }
        }).then(() => Promise.all(this.animations.map(animation => animation.ready))).then(callback);
    }
    pause() {
        for (const animation of this.animations) {
            animation.pause();
        }
    }
    reverse(callback) {
        this.ready.then(() => {
            for (const animation of this.animations) {
                animation.reverse();
            }
        }).then(() => Promise.all(this.animations.map(animation => animation.ready))).then(callback);
    }
    progress(p) {
        for (const animation of this.animations) {
            const {
                activeDuration,
                delay
            } = animation.effect.getComputedTiming();
            animation.currentTime = ((delay || 0) + (activeDuration || 0)) * p;
        }
    }
    cancel() {
        for (const animation of this.animations) {
            animation.cancel();
        }
    }
    onFinish(callback) {
        Promise.all(this.animations.map(animation => animation.finished)).then(callback);
    }
}

// function getInitialFrame(animation: AnimationOptions) {}

// function getCSSAnimation(target: string | null, animation: AnimationOptions, trigger?) {
//   /*
//    * @keyframes <name> {
//    *   ...
//    * }
//    *
//    * if Scrub and view-progress then:
//    *   @supports (animation-timeline: view()) {
//    *     #source {
//    *       view-timeline: --<trigger>;
//    *     }
//    *     #target {
//    *       animation: <name> auto <easing> both;
//    *       animation-timeline: --<trigger>;
//    *       animation-range: cover <start> cover <end>;
//    *     }
//    *   }
//    *   @supports not (animation-timeline: view()) {
//    *     #target {
//    *       animation: <name> 100ms <easing> both paused;
//    *     }
//    *   }
//    *
//    * else:
//    *   #target {
//    *     animation: <name> <duration> <delay> <easing> <fill> <iterations> <play-state>;
//    *   }
//    */
//   return {
//     keyframes: {},
//     animation: '',
//     animationTimeline: '',
//     animationRange: '',
//   };
// }

/**
 * Process a list of AnimationOptions and returns a list of objects with AnimationData and KeyframeEffectOptions.
 * @param {AnimationOptions} animation
 * @param {HTMLElement|null} target
 * @return {{ effect: AnimationData; options: KeyframeEffectOptions }[]}
 */
function getEffectsData(animation, target) {
    // get the processed list of AnimationData objects for the given animation options
    const animations = getNamedEffect(animation, target);

    // process each AnimationData object into a KeyframeEffect object
    return animations.map(effect => {
        // prepare the KeyframeEffectOptions object
        const options = {
            fill: effect.fill,
            easing: getEasing(effect.easing),
            iterations: effect.iterations || Infinity,
            composite: effect.composite,
            direction: getDirection(effect)
        };

        // if this is a TimeAnimation then set the duration and delay as time values
        if (effect.type.startsWith('Time')) {
            options.duration = effect.duration;
            options.delay = effect.delay || 0;
        } else {
            // if ViewTimeline is supported
            if (window.ViewTimeline) {
                // set duration to 'auto'
                options.duration = 'auto';
            } else {
                // if ViewTimeline not supported then put a 100ms value in duration get a progress we can easily relate to
                options.duration = options.duration || 100;
            }
        }
        return {
            effect,
            options,
            id: animation.effectId,
            part: effect.part
        };
    });
}

/**
 * Returns an AnimationGroup object for the given target and animation options.
 * @param {string|null} target
 * @param {AnimationOptions} animationOptions
 * @param {{trigger: string, componentId: string}} [trigger]
 * @return {AnimationGroup}
 */
function getWebAnimation(target, animationOptions, trigger) {
    const element = getElement(target);
    if ((trigger == null ? void 0 : trigger.trigger) === 'pointer-move') {
        const mouseAnimationFactory = getNamedEffect(animationOptions, element);
        return mouseAnimationFactory(element);
    }
    // generate KeyframeEffect objects that represent th
    const data = getEffectsData(animationOptions, element);
    let timeline;

    // if this is a ScrubAnimation with view-progress trigger and the browser supports the ViewTimeline API
    if ((trigger == null ? void 0 : trigger.trigger) === 'view-progress' && window.ViewTimeline) {
        // generate the timeline object
        // @ts-expect-error
        timeline = new ViewTimeline({
            subject: trigger.element || getElement(trigger.componentId)
        });
    }
    let startOffsetAdd;
    let endOffsetAdd;

    // generate an Animation object for each data object
    const animations = data.map(_ref => {
        let {
            effect,
            options,
            id,
            part
        } = _ref;
        const effectTarget = part ? element == null ? void 0 : element.querySelector(`[data-motion-part="${part}"]`) : element;
        const keyframeEffect = new KeyframeEffect(effectTarget || null, [], options);

        // set the keyframes for the KeyframeEffect after measurements and mutations
        fastdom.mutate(() => {
            if ('timing' in effect) {
                keyframeEffect.updateTiming(effect.timing);
            }
            keyframeEffect.setKeyframes(effect.keyframes);
        });
        let animation;
        const isViewProgress = (trigger == null ? void 0 : trigger.trigger) === 'view-progress';
        startOffsetAdd = effect.startOffsetAdd;
        endOffsetAdd = effect.endOffsetAdd;

        // if this is a ScrubAnimation with view-progress trigger and the browser supports the ViewTimeline API
        if (isViewProgress && timeline) {
            animation = new Animation(keyframeEffect, timeline);

            // @ts-expect-error
            animation.rangeStart = getRange(effect.startOffset, effect.startOffsetAdd);
            // @ts-expect-error
            animation.rangeEnd = getRange(effect.endOffset, effect.endOffsetAdd, true);
            animation.play();
        } else {
            animation = new Animation(keyframeEffect);
        }
        if (id) {
            animation.id = id;
        }
        return animation;
    });

    // create an AnimationGroup with the generate animations
    return new AnimationGroup(animations, {
        ...animationOptions,
        trigger: {
            ...(trigger || {})
        },
        startOffsetAdd,
        endOffsetAdd,
        // make sure the group is ready after all animation targets are measured and mutated
        measured: new Promise(resolve => fastdom.mutate(resolve))
    });
}

/**
 * Returns all animations that are currently running on the given element.
 * @param {HTMLElement|string} target
 * @param {string} effectId
 * @return {AnimationGroup|null}
 */
function getElementAnimation(target, effectId) {
    const element = typeof target === 'string' ? getElement(target) : target;
    // somehow get the right animations
    const animations = element == null ? void 0 : element.getAnimations().filter(anim => {
        // @ts-expect-error
        const id = anim.id || anim.animationName;
        // if no id/name just return all animations
        return id ? id.startsWith(effectId) : true;
    });
    return animations != null && animations.length ? new AnimationGroup(animations) : null;
}

function getScrubScene(target, animationOptions, trigger, sceneOptions) {
    if (sceneOptions === void 0) {
        sceneOptions = {};
    }
    const {
        disabled
    } = sceneOptions;
    const animation = getWebAnimation(target, animationOptions, trigger);
    const {
        startOffset,
        endOffset,
        centeredToTarget
    } = animationOptions;
    let typeSpecificOptions = {};
    if (trigger.trigger === 'view-progress' && !window.ViewTimeline) {
        var _offset, _options, _offset2, _options2;
        typeSpecificOptions = {
            start: startOffset && {
                name: startOffset.name,
                offset: (_offset = startOffset.offset) == null ? void 0 : _offset.value,
                add: (_options = animation.options) == null ? void 0 : _options.startOffsetAdd
            },
            end: endOffset && {
                name: endOffset.name,
                offset: (_offset2 = endOffset.offset) == null ? void 0 : _offset2.value,
                add: (_options2 = animation.options) == null ? void 0 : _options2.endOffsetAdd
            },
            viewSource: trigger.element || getElement(trigger.componentId)
        };
    } else if (trigger.trigger === 'pointer-move') {
        typeSpecificOptions = {
            target: animation.target,
            centeredToTarget
        };
    }
    return {
        ...typeSpecificOptions,
        effect(__, p) {
            // @ts-expect-error the type of `p` is dependent on the value of `trigger.trigger`
            animation.progress(p);
        },
        disabled,
        destroy() {
            animation.cancel();
        }
    };
}
export {
    // getInitialFrame,
    // getCSSAnimation,
    getWebAnimation,
    getElementAnimation,
    getScrubScene
};
//# sourceMappingURL=motion.js.map